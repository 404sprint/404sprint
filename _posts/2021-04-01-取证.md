---
layout:     post
title:      Windows取证
subtitle:   学习资料笔记
date:       2021-03-30
author:     Sprint#51264
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - 学习笔记
---
# 引言

forensic investigations
法庭取证调查
事件响应调查

# 概念

司法调查，事件响应人员将黑客、渗透测试者进入系统之后做了什么，留下什么证据，行为轨迹进行梳理还原

渗透测试者有必要留下自己的痕迹以证明没有进行恶意行为或者攻击行为，没有破坏没有下载内容

首页被篡改、公司被入侵，然后就要登录服务器查看攻击者及逆行了什么操作，行为轨迹，有没有留下后门，更多倾向于技术型

关注层面:数字取证/计算机取证/电子取证
智能设备、计算机、手机平板、IOT、有线及无线通讯、存储数据

# 攻击目的

* 炫耀型

    上传黑页、到此一游.txt

* 政治目的型

* 利益链型

    偷数据、爬库，该连接，勒索，挖矿
    (首要目标是止损)

* 抓鸡型
* DDOS型
* 蠕虫感染型
    
    (内网传播，conficker，wannacry)

* 持续性
    
    (长期潜伏式攻击、APT)

# 溯源线索

* 了解黑客目的，针对性强，站在攻击者的角度，不要盲目地全部扫一遍

* 从流量侧发现线索

    * Webshell操作
        
        webshell文件查找
        web日志审计,连接webshell的IP、根据该IP遍历所有日志
        漏洞利用成功，根据时间线查，了解第一次连接webshell时间

    * 异常的外联(通过IOC指标关联)

        漏洞利用成功(修复漏洞后尽快上线，确定没有横向的动作)


    * 横向渗透工具

* 外界情报
    
    听说某公司出局(某系统失陷)，做全盘的检查

* 业务卡顿、服务受影响

* 安全监控设备

# 检测到恶意文件

* 上传到沙箱进行检测
* 检测文件哈希值


# 通用原则
* 维护证据完整性
 
    * 数字取证可以无限数量拷贝进行分析不会被污染破坏
    * 数字HASH值可以验证数据完整性

* 维护监管链
    
    * 物理证据取证需要放入证物袋，每次取出都要又严格记录

    * 数字证物原始版本写保护，进行主拷贝

* 取证分析全部过程记录文档


# 数字取证座右铭

* 不要破坏数据现场

    很难实现，入侵者可能修改命令内容，一旦运行系统的某个命令ls，就再释放一个木马，或者使用某个命令的时候，木马判断已经被发现，自动销毁服务器中的数据

    所以要使用U盘操作系统更加安全，但是U盘申请使用计算机内存也会使其数据发生改变

* 寄存器、CPU缓存、I/O设备缓存等易失性数据几乎无法获取(一旦断电关机或者误操作就发生变化，丢失)

* 系统内存是主要的易失性存储介质取证对象，不修改无法获取其中的数据

* 非易失性存储介质通常使用完整镜像
拷贝保存(U盘、光盘、硬盘)

    镜像不同于文件备份(复制拷贝)

    把硬盘每个磁道的每个扇区的磁极指向标识数据0还是1完整地复制

    即使文件已经被删除，但是在扇区里还占有一定的空间，默认的操作系统上的删除，在磁盘里只是在硬盘分区表开头(第一个字符)做一个标记，标记该文件是删除状态，可以用来存储其他数据，但实际上文件所有内容仍旧在硬盘空间中，可以通过数据恢复工具对删掉的数据进行恢复。

* 正常关机还是直接拔掉电源

    (如果发现服务器被入侵要怎样关机)

    如果直接拔电就会造成保存在内存中的数据丢失

    但是恶意程序如果发现关机行为可能把自己清除抹除犯罪证据，或者对硬盘数据进行擦除

    但是建议直接拔电源，尤其是Linux系统现在使用的是ExT4文件系统(日志型文件系统)，可以通过日志对文件内容进行修复

* 证据搜索

    如今的文件动辄几百G，难以搜索

    * 原数据

        保存下来的数据

    * 信息

        信息分析组成信息链

    * 证据

        信息提炼，攻击轨迹

# 取证科学

* 通过取证还原黑客入侵的轨迹
* 作为渗透测试和黑客的攻击区分标准
    >有没有拿走数据
    * 世纪佳缘事件
    * 印象笔记渗透测试事件

# 取证方法

* 活取证
    >发现服务器被攻击，在未关机时就进行最新鲜的取证
    * 抓取文件metadate、创建时间先、命令历史、分析日志文件、HASH摘要、转存内存信息(最好不要再使用该机器上的任何命令)
    >建议新建用户，主目录下可能有病毒程序，打开终端产生病毒

    * 建议使用未受感染的干净程序(用U盘上的程序进行取证)

* 死取证

    * 关机之后制作硬盘镜像、分析镜像

# 取证工具

* 内存dump工具(活取证)

    >内存时暂时存储程序以及数据的地方，当我们使用WPS处理文稿时，当你在键盘上敲入字符时，它将先被存入内存，当你选择存盘时，内存中的数据才会被存入硬盘

    要把内存中所有的信息拿出来保存一份

    * windows:Dumpit

        内存文件比实际文件稍微大一点，为raw格式

        readme.txt:建议使用USB设备运行而不是直接拷贝，拷贝文件会破坏文件完整性，二是拷贝进去的程序也会受到感染

        保存的是实时的内存信息

        双击就可以使用

        [图片02]

* volatility(易失性的)

    >kali一些版本上没有自带这个软件，需要自行安装，可能会报错，一般缺失的是Crypto插件和distorm3插件，根据错误信息自行下载


    * 常用命令
        `volatility imageinfo -f xp.raw #文件信息，关注profile`

        `volatility hivelist -f xp.raw --profile =WinXPSP3x86 #数据库文件`

        ``volatility -f second.raw --profile=Win7SP1x64 hivelist`查看所有注册表信息

        `volatility -f xp.raw --profile =WinXPSP3x86 hiveudmp -o 0xe124f8a8 #按虚拟内存地址查看注册表信息`
        
        `volatility -f xp.raw --profile=WinXPSP3x86 printkey -K "SAM\Domains\Account\Users\Names" # 用户账号`

        `volatility -f xp.raw --profile=WinXPSP3x86 printkey -K "SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" #最后登录的用户`

        `volatility -f xp.raw --profile=WinXPSP3x86 userassist #正在运行的程序、运行过多少次、最后一次运行时间等`

    * 系统信息dump
    
    `volatility -f second.raw imageinfo`

    [图片03]

    能查看到是什么系统，在以后的操作过程中会需要指定系统

    * 进程dump

        使用dump保存内存文件之后，使用volatility对其进行分析。内存中保存的是当前系统正在运行的信息。其中更多的是核心的内容、正在运行的程序的信息。

        信息传递过程中是加密的，但是传到服务器之后就是解密之后的数据，所以在服务器内存之中很可能就有解密后的信息，假如是淘宝，很可能就能在内存之中看到正在浏览的用户的账号密码。


        >检测出多个内存文件格式，说明几个版本之间的内存文件类似

        `volatility -f second.raw --profile=Win7SP1x64 pslist `#查看进程信息(查找可疑进程、名称奇怪)

        [图片04]

        `volatility -f second.raw --profile=Win7SP1x64 pstree`#能更直观的显示进程与进程之间的关系，进程树

        [图片05]


        如果是对进程表中的某一个进程感兴趣的话可以使用

        `volatility -f second.raw --profile=Win7SP1x64 memdump -p xxxx -D XXXX`#提取某个具体进程的内容到某个已有目录

        (在进程信息中很可能有恶意程序自己的函数或者调用信息的关键字，有哪些动作)

        >stings 2012.dmp | grep xxxx #查找关键字

        >知识补充:[Linux中的程序和进程，PID和PPID](https://blog.csdn.net/sinat_25457161/article/details/48596797)
        >程序是静止的，程序就是磁盘上的一个文件
        >进程是一个正在执行的程序的实例，进程是动态的
        >一旦程序被操作系统加载进内存，呢么程序就成为了进程

        >PID(process ID):PID是程序被操作系统加载到内存成为进程后动态分配的资源，每次程序执行的时候，操作系统都会重新加载，PID在每次加载的时候都是不同的

        >PPID(parent process ID):PPID是程序的父进程号

        >一个进程创建的另一个新进程称为子进程、相反，创建子进程的进程就称为父进程，对于一个普通的用户进程，它的父进程就是执行它的哪个Shell，对于linux，shell就是bash


    * 注册表dump

        windows注册表信息也缓存在内存之中，存放注册表信息的文件称为hive(蜂巢)，由很多个hive组成了注册表信息，安装的软件很多都会修改注册表，病毒也很可能修改注册表，通过查询内存也能知道大量计算机的信息，能得到用户账户名和哈希值

            SAM 账户信息
            SOFTWARE 安装的软件信息

        `volatility -f second.raw --profile=Win7Sp1x64 hivelist `#查看内存中的蜂巢文件(账户信息SAM，已经安装的软件信息SOFTWARE、不止包括后安装的第三方软件信息，还有自带的系统应用的软件信息(画图、计算器...))、当然也有绿色软件不在注册表中留下信息，所以就无法在注册表中查到对应信息

        [图片06]

        `volatility -f second.raw --profile=Win7SP1x64 hivedump -o (内存地址)`

        [图片07]

        >因为查看的是内存文件，所以应该使用hvie的内存地址来进行dump，计算机寻址是使用虚地址，要输入内存的虚地址(virtual)

        [虚地址和物理地址](https://www.cnblogs.com/ricklz/p/11037814.html)

        >注册表的信息都是通过内存信息查看的，实际检测的是内存文件而不是注册表文件，要查看所有信息就要指定内存地址，蜂巢把自己加载到内存地址里，某个地址起存什么什么信息，哪个空间放什么信息，所以如果dump一个蜂巢中的所有信息，就要指定一个地址即存放对应hive文件内存的起始地址

        虚拟地址的长度可能不一样，如果是64位操作系统，那么可寻址的总长就是2^64，如果是32位那么长度就是2^32

        >停止滚屏:ctrl+C 暂停:ctrl+S 解锁:ctrl+Q

    * 用户dump
        
        >既然是可以把注册表hive文件内容进行dump，那是否可以直接把注册表中的键值具体路径具体进行提取

        随着系统的使用，信息越来越多，注册表表内容很多，一时dump不完

        注册表可以理解是数据库存储结构，只要知道它的键值，指定账户在注册表中的存储路径，就能知道账户信息

        >注册表编辑器:regedit

        默认情况下SAM节点操作系统管理员也无法查看，可以赋予权限进行查看

        >用本系统查看的时候(win7)，可以发现，默认system有权限直接查看SAM信息，但是管理员默认无法读取SAM信息，可以运行get system得到system权限，如果没有system权限还要先进行本地提权然后在进行查看

        不过值得注意的是，如果在SAM目录处赋予权限，只是对SAM这个路径有权限，对于其中的子键还是没有权限，所以在赋予权限的时候要选择对其目录下的其他键值也有高级权限，要点击高击设置一项,配置高级权限的时候选择**继承**。

        然后在有效权限中输入当前用户名对权限进行查看。(可删可写)

        >如此一来也就是说可以通过注册表查找到用户的相关信息，但是有内存文件的话就有注册表的缓存内容，可以通过**关键字查找**，即**关键路径**查找键值内容。

        `volatility -f second.raw --profile=Win7SP1x64 printkey -K "Sam\Domains\Account\Users\Names"`

        [图片01]

        >在原机器上查有多出来的账号但是这里没有查到是因为对应的服务没有使用，所以账号没有加载到内存中

        也就是说只要知道了路径，就可以查注册表中任意的键值。

        **如果想知道在进行dump时登录的是哪个账户**

        `volatility -f second.raw --prfile=Win7SP1x64 printkey -K "SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"`

        [图片08]
        
        显示的信息可能有些多，需要根据路径中的关键字判断是系统用户还是真实用户

        >其中last update并不是用户最后登录的时间，而是最后一次对用户进行更改的时间

        **如果想知道最后登录的是哪个用户**

        `volatility -f second.raw --profile=Win7SP1x64 userassist`

        可以显示其运行过哪些程序、正在运行什么、运行了多少次、最后一次运行时间
        
        [图片09]

    * 密码HASHdump

        用户账号加密之后密文的哈希值也放在注册表里放在内存中，得到密码HASH值就可以使用

        `volatility -f second.raw --profile=Win7SP1x64 hashdump -y system -s SAM`# -y指的是SYSTEM注册表键值对应的的内存虚地址，-s指的是SAM注册表键值对应的内存虚地址


    * 命令行历史

        >使用cmd打开命令行窗口的历史

        `volatility -f second.raw --profile=Win7SP1x64 cmdscan`

        可以看到对应的进程id

        [图片10]

    * 网络连接


        >在操作系统被植入木马后通常会连接C2服务器，通过查看网络连接可以发现异常连接行为

        `volatility -f second.raw --profile=Win7SP1x64 netscan`
        
        [图片11]

        (包括监听中、关闭、已建立的)

    * IEhistory

        可以看到下载了什么程序、访问了哪个url、由哪个用户发起的请求(可以用来定位人)，只要是启动了IE的或者间接打开了IE的都会被记录(如果有恶意连接某个黑客网站下载某个恶意的exe文件就可以调查)

        `volatility -f second.raw --profile=Win7SP1x64 iehistory`
        

        [图片12]

    * Firefoxhistory

       http://downloads.volatilityfoundation.org/contest/2014/DaveLasalle_ForensicSuite.zip

       `volatility -f second.raw --profile=Win7SP1x64 firefoxhistory`#查看firefox历史记录

    * USN日志记录插件

        EST是日志记录系统，但是NTFS也有USN日志记录，可以记录分区中内容的变化，可以追踪硬盘内容的变化(但是不记录具体内容，指文件中写的内容，只会记录文件状态(大小，写入删除))

        https://github.com/tomspencer/volatility/tree/master/usnparser

        `volatility -f second.raw --profile=Win7SP1x64 usnparser`



        临时文件日志文件

        可以看到所有文件状态改变的动作

        生成的信息量很大，可以进行导出做成excel进行筛选,导出使用的参数为

        `volatility -f second.raw --profile=Win7SP1x64 usnparser --output=csv(文件格式) --output-file=usn.csv(文件名)`

    * Timeline(时间线)

        usn只从硬盘读写方面勾画活动情况

        timeliner从多个位置收集大量信息活动信息，尽最大能力把这台主机上发生过什么事情、做过什么操作进行勾画

        >所有的活动

        [图片13]

        什么时间、产生什么进程、使用什么文件、进程ID是多少


* 内存取证发现恶意软件

    https://github.com/volatilityfoundation/volatility/wiki/Memory-Samples

    https://code.google.com/archive/p/volatility/wikis/SampleMemoryImages.wiki

        














